from abc import ABC, abstractmethod
from copy import copy
from csv import reader
import matplotlib.pyplot as plt
from matplotlib.gridspec import GridSpec
from matplotlib import cm
import netCDF4 as ncdf
import numpy as np
import pandas as pd
from pathlib import Path
import netCDF4 as ncdf
from string import ascii_lowercase
from warnings import warn

from cartopy import crs as ccrs
import cartopy.io.shapereader as shpreader
import cartopy.feature as cfeature

from jllutils import units as junits
from jllutils import miscutils
from muses_tools.tools.atmosphere.column_integrate import column_integrate

from . import readers
from .conversions import bt
from .readers import get_nc_var, convert_sounding_ids, convert_sounding_array
from .helpers import LetterLabeler, AbstractLabeler, DeprecatedError, find_attribute

from typing import Optional, Sequence, Tuple, Callable

_reader = shpreader.Reader(str(Path(__file__).parent / 'geodata' / 'cb_2018_us_state_20m' / 'cb_2018_us_state_20m.shp'))
_states = _reader.geometries()
_state_features = cfeature.ShapelyFeature(_states, ccrs.PlateCarree())


class AbstractMapFeature(ABC):
    @abstractmethod
    def add(self, ax):
        pass


class MapFeatureCoastlines(ABC):
    def add(self, ax):
        ax.coastlines()


class MapFeatureStates(ABC):
    def add(self, ax):
        ax.add_feature(_state_features, facecolor='none', edgecolor='k')

    
def _is_freq_consistent(freq):
    deltas = _freq_consistency_diff(freq)
    return np.allclose(deltas, 0)

def _freq_consistency_diff(freq):
    deltas = np.diff(freq, axis=0)
    return deltas[~np.isnan(deltas)]


def _are_files_matched(sid, sid2, freq, freq2):
    if freq.shape != freq2.shape:
        raise ValueError('Frequencies are not matched (different shapes)')
    # If fills in one frequency, make them fills in both.
    # Necessary because we had to skip some soundings in
    # the UWis v1 run because of a bug.
    either_nans = np.isnan(freq) | np.isnan(freq2)
    freq[either_nans] = np.nan
    freq2[either_nans] = np.nan

    if not np.array_equal(sid, sid2):
        raise ValueError('SoundingIDs are not matched')
    elif not np.allclose(freq, freq2, equal_nan=True):
        raise ValueError('Frequencies are not matched')


class AbstractIdConverter(ABC):
    @abstractmethod
    def convert_ids(self, ds):
        pass

class SummaryIdConverter(AbstractIdConverter):
    def __init__(self, date: Optional[str] = None, id_var='target_id'):
        self.id_var = id_var
        self.date = date

    def _get_date(self, ds):
        if self.date is not None:
            return self.date

        if 'datetime_utc' in ds.variables.keys():
            ymd = np.squeeze(np.unique(ds['datetime_utc'][:, :3], axis=0))
            if np.size(ymd) != 3:
                raise NotImplementedError(f'This summary file has >1 unique year/month/day ({ds.filepath()})')
            y, m, d = ymd
            return f'{y:04d}{m:02d}{d:02d}'

        raise NotImplementedError(f'Cannot get the date for a summary file without datetime_utc ({ds.filepath()})')

        
    def convert_ids(self, ds):
        ids = ds[self.id_var][:].data  # assume that the ID will not be a fill value
        ids = [f'{i:012d}' for i in ids]
        date = self._get_date(ds)
        return np.array([f'{date}_{i[0:3]}_{i[5:7]}_{i[8:10]}_{i[11]}' for i in ids])


class AbstractWindowStat(ABC):
    """Base class for statistics which compute one spectra value per sounding from a full spectrum.

    Note that many subclasses are intended for use with profile variables (i.e. the retrieved VMRs
    or temperatures) but still use the "spectrum" and "frequency" terminology.

    Parameters
    ----------
    combined_file
        Path to a file generated by ``py-combine``

    freq_var
        The name of the frequency variable in the ``combined_file``. Any variable name or path that 
        :func:`get_nc_var` understands is allowed.

    spec_var
        The name of the spectral variable (e.g. emissivity, radiance, etc.) in the ``combined_file``. 
        Any variable name or path that :func:`get_nc_var` understands is allowed.

    window_min, window_max
        The lowest and highest frequencies to include in the window when computing the statistics.

    lon_var, lat_lat
        Name or path to the longitude and latitude variables in ``combined_file``.

    quality_var
        Name or path to the quality flag variable in ``combined_file``. Used with ``filter_on_quality``.
        If this is provided, the dataframe will include the quality flag as a column.

    filter_on_quality
        Controls whether the dataframe returned by :meth:`compute_window_stats` includes only good quality
        soundings or all soundings.

        * If ``quality_var`` is ``None``, then the dataframe will contain all soundings (good and bad)
        * If ``filter_on_quality`` is ``None``, then the dataframe will contain only good soundings if 
          ``quality_var`` is provided, and all soundings if it is not.
        * If ``filter_on_quality`` is ``True`` or ``False`` and ``quality_var`` is given, then the boolean
          sets whether only good soundings are in the dataframe (``True``) or all soundings are (``False``).

    id_var
        Name or path to the sounding ID variable. If given, then the dataframes will be indexed by the sounding
        ID (which is useful for merging different runs).
    """
    def __init__(self, combined_file: str, freq_var: str, spec_var: str, window_min: float, window_max: float, 
                 lon_var: str = 'LONGITUDE', lat_var: str = 'LATITUDE', quality_var: Optional[str] = None, filter_on_quality: bool = None,
                 id_var: Optional[str] = None):
        self.combined_file = combined_file
        self._freq_var = freq_var
        self._spec_var = spec_var
        self._lon_var = lon_var
        self._lat_var = lat_var
        self._id_var = id_var
        self._quality_var = quality_var
        self._filter_quality = quality_var is not None if filter_on_quality is None else filter_on_quality
        self._win_min = min(window_min, window_max)  # allow for the limits to have been flipped, which can happen easily when working in pressure space
        self._win_max = max(window_min, window_max)

    @property
    @abstractmethod
    def label(self):
        """Return a label describing this statistic"""

    @abstractmethod
    def operation(self, freq, spec):
        """Given 2D arrays of frequency and spectral information, return a 1D vector with one value of spectral information per sounding"""

    def compute_window_stats(self) -> pd.DataFrame:
        """Create a dataframe with the longitude, latitude, and statistics for each sounding in the combined file."""
        with ncdf.Dataset(self.combined_file) as ds:
            lon = get_nc_var(ds, self._lon_var)
            lat = get_nc_var(ds, self._lat_var)
            freq = get_nc_var(ds, self._freq_var) if self._freq_var else None
            spec = get_nc_var(ds, self._spec_var) if self._spec_var else None
            qual_flag = get_nc_var(ds, self._quality_var) if self._quality_var is not None else None
            sids = self._convert_sounding_ids(ds)
            
        freq, spec = self._get_window(freq, spec)
        spec_stat = self.operation(freq, spec)

        df = pd.DataFrame({'longitude': lon, 'latitude': lat, 'spec_stat': spec_stat, 'qual_flag': qual_flag})
        if sids is not None:
            df.index = sids

        if self._filter_quality:
            qq = qual_flag == 1
            return df.loc[qq, :]
        else:
            return df
        
    def _get_window(self, freq, spec):
        if not _is_freq_consistent(freq):
            spec = np.copy(spec)
            for i, frow in enumerate(freq):
                xx_window = (frow >= self._win_min) & (frow <= self._win_max)
                spec[i, ~xx_window] = np.nan
            return freq, spec
        else:
            # Can just use a frequency vector since all soundings use the same frequency
            # Take the mean to avoid the issue of the row being NaNs
            freq_vec = np.nanmean(freq, axis=0)
            xx_window = (freq_vec >= self._win_min) & (freq_vec <= self._win_max)
            return freq[:, xx_window], spec[:, xx_window]

    def _convert_sounding_ids(self, ds):
        if isinstance(self._id_var, AbstractIdConverter):
            return self._id_var.convert_ids(ds)
        elif self._id_var is not None:
            return convert_sounding_ids(get_nc_var(ds, self._id_var))
        else:
            return None


class Window2D(AbstractWindowStat):
    """A class that 
    """
    def __init__(self, combined_file: str, spec_var: str, lon_var: str = 'LONGITUDE', lat_var: str = 'LATITUDE', quality_var: Optional[str] = None, 
                 filter_on_quality: bool = None, id_var: Optional[str] = None):

        raise DeprecatedError('Window2D class is deprecated. Use WindowDirectRead instead.')


class WindowDirectRead(AbstractWindowStat):
    """A class to read values directly from a combined file with no additional operation applied.

    This is useful when you want to plot quantity that is a scalar in individual soundings in a plotting
    function that needs some child class of :class:`AbstractWindowStat`.

    Parameters
    ----------
    combined_file
        Path to a file generated by ``py-combine``

    spec_var
        The name of the spectral variable (e.g. emissivity, radiance, etc.) in the ``combined_file``. 
        Any variable name or path that :func:`get_nc_var` understands is allowed.

    lon_var, lat_lat
        Name or path to the longitude and latitude variables in ``combined_file``.

    quality_var
        Name or path to the quality flag variable in ``combined_file``. Used with ``filter_on_quality``.
        If this is provided, the dataframe will include the quality flag as a column.

    filter_on_quality
        Controls whether the dataframe returned by :meth:`compute_window_stats` includes only good quality
        soundings or all soundings.

        * If ``quality_var`` is ``None``, then the dataframe will contain all soundings (good and bad)
        * If ``filter_on_quality`` is ``None``, then the dataframe will contain only good soundings if 
          ``quality_var`` is provided, and all soundings if it is not.
        * If ``filter_on_quality`` is ``True`` or ``False`` and ``quality_var`` is given, then the boolean
          sets whether only good soundings are in the dataframe (``True``) or all soundings are (``False``).

    id_var
        Name or path to the sounding ID variable. If given, then the dataframes will be indexed by the sounding
        ID (which is useful for merging different runs).
    """
    def __init__(self, combined_file: str, spec_var: str, lon_var: str = 'LONGITUDE', lat_var: str = 'LATITUDE', 
                 quality_var: Optional[str] = None, filter_on_quality: bool = None, id_var: Optional[str] = None):
        super().__init__(
            combined_file=combined_file,
            freq_var=None,
            spec_var=spec_var,
            window_min=0,
            window_max=0,
            lon_var=lon_var,
            lat_var=lat_var,
            quality_var=quality_var,
            filter_on_quality=filter_on_quality,
            id_var=id_var
        )

    @property
    def label(self):
        return self._spec_var

    def operation(self, freq, spec):
        return spec

    def _get_window(self, freq, spec):
        return freq, spec



class WindowMean(AbstractWindowStat):
    """Computes the mean of the spectral variable in the window.
    
    All inputs are the same as :class:`AbstractWindowStat`.
    """
    @property
    def label(self):
        return f'Mean {self._spec_var} in {self._win_min} to {self._win_max} cm$^{{-1}}$'
        
    def operation(self, freq, spec):
        return np.nanmean(spec, axis=1)


class PanMean(WindowMean):
    """Computes the mean PAN between 825 and 215 hPa.

    All inputs are the same as :class:`AbstractWindowStat`.

    Note that this class has two extra attributes: ``stat_scale`` which is how much the PAN in the combined files should be scaled by to match the 
    label given in ``cblabel``.
    """
    def __init__(self, combined_file: str, freq_var: str = 'Pressure', spec_var: str = 'Species', window_min: float = 215, window_max: float = 825, 
                 lon_var: str = 'Longitude', lat_var: str = 'Latitude', quality_var: str = 'Quality', filter_on_quality: bool = True, id_var: Optional[str] = None):
        super().__init__(combined_file, freq_var, spec_var, window_min, window_max, lon_var, lat_var, quality_var, filter_on_quality, id_var)
        self.stat_scale=1e12, 
        self.cblabel=f'Mean PAN VMR between {window_max} and {window_min} hPa (ppt)'


class XgasCalc(AbstractWindowStat):
    def __init__(self, combined_file: str, file_kind: str = 'std', pres_range: Tuple[float, float] = (215.0, 825.1), species_name: str = 'PAN', scaling: float = 'default',
                 lon_var: str = 'Longitude', lat_var: str = 'Latitude', quality_var: Optional[str] = None, filter_on_quality: bool = None,
                 id_var: Optional[str] = None, show_integration_progress: bool = True):

        scalings = {'pan': 1e9}
        self.combined_file = combined_file
        if file_kind.lower() == 'std':
            self._species_var = 'Species'
            self._airdens_var = 'Retrieval/AirDensity'
            self._pres_var = 'Pressure'
            self._alt_var = 'Altitude'
            self._retlog_var = 'Characterization/RetrieveInLog'
            self._missing_value = -998 # use -998 to ensure we never accidentally include a -999
            self._scaling = scaling if scaling != 'default' else scalings.get(species_name.lower(), 1.0)
        else:
            raise NotImplementedError(f'The file kind "{file_kind}" has not been implemented')
        self._pres_range = sorted(pres_range)  # ensure that the smaller pressure is first
        self._species_name = species_name
        self._lon_var = lon_var
        self._lat_var = lat_var
        self._id_var = id_var
        self._quality_var = quality_var
        self._filter_quality = quality_var is not None if filter_on_quality is None else filter_on_quality
        self._show_int_prog = show_integration_progress
        

    @property
    def label(self):
        """Return a label describing this statistic"""
        return f'X{self._species_name}'

    def operation(self, vmrs, altitude, pressure, air_density, is_linear: bool):
        """Given 2D arrays of frequency and spectral information, return a 1D vector with one value of spectral information per sounding"""
        nprof = np.shape(vmrs)[0]
        xgas = np.full(nprof, np.nan)
        pbar = miscutils.ProgressBar(nprof, prefix=f'Integrating {self._species_name}')
        for iprof in range(nprof):
            if self._show_int_prog:
                pbar.print_bar()
            xx_include = (pressure[iprof] > self._pres_range[0]) & (pressure[iprof] < self._pres_range[1]) & (vmrs[iprof] > self._missing_value) & (np.isfinite(vmrs[iprof]))
            if np.sum(xx_include) == 0:
                continue
            result = column_integrate(vmrs[iprof][xx_include], air_density[iprof][xx_include], altitude[iprof][xx_include], linearFlag=is_linear)
            xgas[iprof] = result.column / result.columnAir
        return xgas * self._scaling


    def compute_window_stats(self) -> pd.DataFrame:
        with ncdf.Dataset(self.combined_file) as ds:
            lon = get_nc_var(ds, self._lon_var)
            lat = get_nc_var(ds, self._lat_var)
            species = get_nc_var(ds, self._species_var)
            airdens = get_nc_var(ds, self._airdens_var)
            altitude = get_nc_var(ds, self._alt_var)
            pressure = get_nc_var(ds, self._pres_var)
            retrieved_in_log = get_nc_var(ds, self._retlog_var)
            qual_flag = get_nc_var(ds, self._quality_var) if self._quality_var is not None else None
            sids = self._convert_sounding_ids(ds)

        retlog_flag = np.unique(retrieved_in_log[np.isfinite(retrieved_in_log) & (retrieved_in_log > self._missing_value)].astype('int'))
        if np.size(retlog_flag) != 1:
            raise NotImplementedError(f'Got mixed linear/log retrievals: unique values for retlog were {retlog_flag}')
        retlog_flag = retlog_flag.item()
        if retlog_flag < 0 or retlog_flag > 1:
            raise NotImplementedError(f'Got a value for the retrieved in log flag not 0 or 1: {retlog_flag}')

        linear_flag = not bool(retlog_flag)
        xgas = self.operation(vmrs=species, altitude=altitude, pressure=pressure, air_density=airdens, is_linear=linear_flag)

        df = pd.DataFrame({'longitude': lon, 'latitude': lat, 'spec_stat': xgas, 'qual_flag': qual_flag})
        if sids is not None:
            df.index = sids

        if self._filter_quality:
            qq = qual_flag == 1
            return df.loc[qq, :]
        else:
            return df



class XPan825(WindowDirectRead):
    """Extracts XPan825 or x_col_ft from a summary file.

    This was a quantity given in some summary files Susan pointed me to. This class can handle a few different ways that
    sounding IDs can be written to the netCDF file.

    spec_var
        The name of the XPAN variable in the ``combined_file``. 
        Any variable name or path that :func:`get_nc_var` understands is allowed.

    lon_var, lat_lat
        Name or path to the longitude and latitude variables in ``combined_file``.

    quality_var
        Name or path to the quality flag variable in ``combined_file``. Used with ``filter_on_quality``.
        If this is provided, the dataframe will include the quality flag as a column.

    filter_on_quality
        Controls whether the dataframe returned by :meth:`compute_window_stats` includes only good quality
        soundings or all soundings.

        * If ``quality_var`` is ``None``, then the dataframe will contain all soundings (good and bad)
        * If ``filter_on_quality`` is ``None``, then the dataframe will contain only good soundings if 
          ``quality_var`` is provided, and all soundings if it is not.
        * If ``filter_on_quality`` is ``True`` or ``False`` and ``quality_var`` is given, then the boolean
          sets whether only good soundings are in the dataframe (``True``) or all soundings are (``False``).

    id_var
        Name or path to the sounding ID variable. If given, then the dataframes will be indexed by the sounding
        ID (which is useful for merging different runs).
    """
    def __init__(self, combined_file: str, spec_var: str = 'XPAN825', lon_var: str = 'Longitude', lat_var: str = 'Latitude', 
                 quality_var: Optional[str] = 'quality_flag', filter_on_quality: bool = None, id_var: Optional[str] = None):

        if spec_var is None:
            with ncdf.Dataset(combined_file) as ds:
                if 'XPAN825' in ds.variables.keys():
                    spec_var = 'XPAN825'
                elif 'x_col_ft' in ds.variables.keys():
                    spec_var = 'x_col_ft'
                else:
                    raise IOError('Could not identify XPAN variable')

        super().__init__(
            combined_file=combined_file,
            spec_var=spec_var,
            lon_var=lon_var,
            lat_var=lat_var,
            quality_var=quality_var,
            filter_on_quality=filter_on_quality,
            id_var=id_var
        )

    @property
    def label(self):
        quantity = super().label
        with ncdf.Dataset(self.combined_file) as ds:
            units = ds[self._spec_var].Units
            units = units.replace('(', '').replace(')', '')
        return f'{quantity} ({units})'

    def _convert_sounding_ids(self, ds):
        if isinstance(self._id_var, AbstractIdConverter):
            return self._id_var.convert_ids(ds)
        elif self._id_var is None:
            return None
        elif isinstance(self._id_var, bool) and self._id_var:
            sid_var = 'SoundingArray'
            date_var = 'DateArray'
        elif isinstance(self._id_var, str):
            sid_var = self._id_var
            date_var = 'DateArray'
        else:
            sid_var, date_var = self._id_var

        sids = get_nc_var(ds, sid_var)
        dates = get_nc_var(ds, date_var)
        return convert_sounding_array(sids, dates)


class XColFt(WindowDirectRead):
    """Extracts x_col_ft from a summary file.

    This was a quantity given in some summary files Susan pointed me to. This class can handle a few different ways that
    sounding IDs can be written to the netCDF file.

    spec_var
        The name of the XPAN variable in the ``combined_file``. 
        Any variable name or path that :func:`get_nc_var` understands is allowed.

    lon_var, lat_lat
        Name or path to the longitude and latitude variables in ``combined_file``.

    id_var
        Name or path to the sounding ID variable. If given, then the dataframes will be indexed by the sounding
        ID (which is useful for merging different runs).

    Note
    ----
    This has no option to filter on quality flags; it assumes it is being called on a Lite summary file that 
    does not have any bad soundings.
    """
    def __init__(self, combined_file: str, spec_var: str = 'x_col_ft', lon_var: str = 'longitude', lat_var: str = 'latitude', 
                 id_var: Optional[str] = None):
                    
        super().__init__(
            combined_file=combined_file,
            spec_var=spec_var,
            lon_var=lon_var,
            lat_var=lat_var,
            filter_on_quality=False,
            id_var=id_var
        )

    @property
    def label(self):
        quantity = super().label
        with ncdf.Dataset(self.combined_file) as ds:
            units = ds[self._spec_var].units
            units = {'1e-9': 'ppb'}.get(units, units)
        return f'{quantity} ({units})'
    
    
class WindowDiffMean(WindowMean):
    """Computes the mean difference in the window between two spectral variables.

    Inputs are similar to :class:`AbstractWindowStat`, except ``spec_var`` is replaced with ``spec_var1`` 
    and ``spec_var2``. These are the variables to difference (1 minus 2). 

    ``perdiff`` indicates whether to do a percent difference or regular one.
    """
    def __init__(self, combined_file: str, freq_var: str, spec_var1: str, spec_var2: str, 
                 window_min: float, window_max: float, lon_var: str = 'LONGITUDE', lat_var: str = 'LATITUDE', 
                 quality_var: Optional[str] = None, filter_on_quality: bool = None, perdiff: bool = False, id_var: Optional[str] = None):
        super().__init__(combined_file=combined_file, freq_var=freq_var, spec_var=spec_var1, window_min=window_min, window_max=window_max, 
                         lon_var=lon_var, lat_var=lat_var, quality_var=quality_var, filter_on_quality=filter_on_quality, id_var=id_var)
        self._spec_var2 = spec_var2
        self._use_perdiff = perdiff
        
    @property
    def label(self):
        return f'Mean {self._spec_var} - {self._spec_var2} in {self._win_min} to {self._win_max} cm$^{{-1}}$'
        
    def compute_window_stats(self):
        with ncdf.Dataset(self.combined_file) as ds:
            lon = get_nc_var(ds, self._lon_var)
            lat = get_nc_var(ds, self._lat_var)
            freq = get_nc_var(ds, self._freq_var)
            spec1 = get_nc_var(ds, self._spec_var)
            spec2 = get_nc_var(ds, self._spec_var2)
            qual_flag = get_nc_var(ds, self._quality_var) if self._quality_var is not None else None
            sids = self._convert_sounding_ids(ds)
            
        spec = spec1 - spec2 if not self._use_perdiff else (spec1 - spec2)/spec2 * 100
        freq, spec = self._get_window(freq, spec)
        spec_stat = self.operation(freq, spec)
        df = pd.DataFrame({'longitude': lon, 'latitude': lat, 'spec_stat': spec_stat, 'qual_flag': qual_flag})
        if sids is not None:
            df.index = sids

        if self._filter_quality:
            qq = qual_flag == 1
            return df.loc[qq, :]
        else:
            return df
    

class WindowDiffRMS(WindowDiffMean):
    @property
    def label(self):
        with ncdf.Dataset(self.combined_file) as ds:
            freq_units = find_attribute(get_nc_var(ds, self._freq_var, read_array=False), {'unit', 'units'}, return_value=True)
        return f'RMS {self._spec_var} - {self._spec_var2} in {self._win_min} to {self._win_max} ({freq_units})'

    def operation(self, freq, spec):
        return np.sqrt(np.nanmean(spec**2, axis=1))


class WindowFileDiffMean(WindowMean):
    """Computes the mean difference in the window between a spectral variable in two different files.

    Inputs are similar to :class:`AbstractWindowStat`, except two additional inputs are needed:

    * ``combined_file2`` is the second file in the difference (stat will be ``combined_file`` - ``combined_file2``)
    * ``id_var`` is the variable name/path for sounding IDs in the combined files. This is used to check that the
      two files are matched up.
    * ``perdiff`` indicates whether to compute a percent difference or a regular one.
    """
    def __init__(self, combined_file, combined_file2, id_var, freq_var, spec_var, window_min, window_max,
                 lon_var='LONGITUDE', lat_var='LATITUDE', quality_var: Optional[str] = None, filter_on_quality: bool = None,
                 perdiff: bool = False, index_by_sid: bool = False):
        super().__init__(combined_file=combined_file, freq_var=freq_var, spec_var=spec_var, window_min=window_min, window_max=window_max, 
                         lon_var=lon_var, lat_var=lat_var, quality_var=quality_var, filter_on_quality=filter_on_quality, id_var=id_var)
        self.combined_file2 = combined_file2
        self._use_perdiff = perdiff
        self._index_by_sid = index_by_sid
        
    @property
    def label(self):
        return f'Mean {self._spec_var} file1 - file2 in {self._win_min} to {self._win_max} cm$^{{-1}}$'
    
    def compute_window_stats(self):
        with ncdf.Dataset(self.combined_file) as ds:
            lon = get_nc_var(ds, self._lon_var)
            lat = get_nc_var(ds, self._lat_var)
            sid1 = self._convert_sounding_ids(ds)
            freq1 = get_nc_var(ds, self._freq_var)
            spec1 = get_nc_var(ds, self._spec_var)
            qual_flag1 = get_nc_var(ds, self._quality_var) if self._quality_var is not None else None
            
        with ncdf.Dataset(self.combined_file2) as ds:
            # We assume that if the sounding IDs match the lat/lon do
            sid2 = self._convert_sounding_ids(ds)
            freq2 = get_nc_var(ds, self._freq_var)
            spec2 = get_nc_var(ds, self._spec_var)
            qual_flag2 = get_nc_var(ds, self._quality_var) if self._quality_var is not None else None
            
        _are_files_matched(sid1, sid2, freq1, freq2)
        freq, spec = self._get_window(freq1, spec1 - spec2 if not self._use_perdiff else (spec1 - spec2)/spec2 * 100)
        spec_stat = self.operation(freq, spec)
        df = pd.DataFrame({'longitude': lon, 'latitude': lat, 'spec_stat': spec_stat, 'qual_flag1': qual_flag1, 'qual_flag2': qual_flag2})
        if self._index_by_sid:
            df.index = sid1
        if self._filter_quality:
            qq = (qual_flag1 == 1) & (qual_flag2 == 1)
            return df.loc[qq, :]
        else:
            return df


class WindowAtLevel(AbstractWindowStat):
    """Extract a value at or near a given vertical level/spectral frequency.

    This reads in the coordinate ``freq_var`` from the ``combined_file`` and, for each
    sounding, finds the index where ``freq_var`` is closest to ``target_level`` and outputs
    that in the dataframe returned from :meth:`compute_window_stats`.

    Inputs are the same as :class:`AbstractWindowStat` except for the additional input
    ``target_level``. This is the level to search for in the ``freq_var`` (and must be in 
    the same units as ``freq_var``).
    """
    def __init__(self, combined_file: str, target_level: float, freq_var: str = 'Pressure', spec_var: str = 'Species', window_min: float = 0, window_max: float = 1100, 
                 lon_var: str = 'Longitude', lat_var: str = 'Latitude', quality_var: str = 'Quality', filter_on_quality: bool = True, id_var: Optional[str] = None):
        super().__init__(combined_file, freq_var, spec_var, window_min, window_max, lon_var, lat_var, quality_var, filter_on_quality, id_var)
        self.target_level = target_level
        
    @property
    def label(self):
        return f'{self._spec_var} at level {self.target_level}'
        
    def operation(self, freq, spec):
        # NB: freq can be e.g. pressure, it's just reused from spectral variables
        if np.ndim(freq) == 1:
            # Easy case: all soundings have the same levels, so we only need to find it once
            idx = np.argmin(np.abs(freq - self.target_level))
            return spec[:, idx]
        else:
            # More complicated: can't assume the level is at the same place in every sounding
            # Makes use of numpy's advanced indexing to efficiently select one value per level
            # (https://numpy.org/doc/stable/user/basics.indexing.html#advanced-indexing)
            # If a row is all NaNs, then nanargmin raises a ValueError, so we have to skip those
            # rows and manually enforce that they be NaNs
            idx = np.full(freq.shape[0], -1)
            xx = np.all(np.isnan(freq), axis=1)
            absdelta = np.abs(freq - self.target_level)
            idx[~xx] = np.nanargmin(absdelta[~xx], axis=1)
            values = spec[(np.arange(spec.shape[0]), idx)]
            values[xx] = np.nan
            return values


class WindowAtLevelIndex(AbstractWindowStat):
    def __init__(self, combined_file: str, target_index: int, freq_var: str = 'Pressure', spec_var: str = 'Species', window_min: float = 0, window_max: float = 1100, 
                 lon_var: str = 'Longitude', lat_var: str = 'Latitude', quality_var: str = 'Quality', filter_on_quality: bool = True, id_var: Optional[str] = None):
        super().__init__(combined_file, freq_var, spec_var, window_min, window_max, lon_var, lat_var, quality_var, filter_on_quality, id_var)
        self.target_index = target_index
        
    @property
    def label(self):
        return f'{self._spec_var} at level index={self.target_index}'

    def operation(self, freq, spec):
        if not np.ndim(spec) == 2:
            raise TypeError(f'Variable {self.spec_var} in {self.combined_file} is not 2D')

        return spec[:, self.target_index]

    def _get_window(self, freq, spec):
        return freq, spec


class WindowAtSurface(AbstractWindowStat):
    """Get the value of the VMR or similar variable at the surface.

    Unlike most of the other ``Window*`` classes, this one only works as
    intended if the coordinate (i.e. ``freq_var``) variable is pressure.
    It searches each sounding's pressure levels to find the index with the
    greatest non-fill/non-NaN pressure and considers that the surface.

    Inputs are all the same as :class:`AbstractWindowStat`.
    """
    def __init__(self, combined_file: str, freq_var: str = 'Pressure', spec_var: str = 'Species', window_min: float = 0, window_max: float = 1100, 
                 lon_var: str = 'Longitude', lat_var: str = 'Latitude', quality_var: str = 'Quality', filter_on_quality: bool = True, id_var: Optional[str] = None):
        super().__init__(combined_file, freq_var, spec_var, window_min, window_max, lon_var, lat_var, quality_var, filter_on_quality, id_var)
        
    @property
    def label(self):
        return f'{self._spec_var} at surface'
        
    def operation(self, freq, spec):
        surf_inds = self.find_surf_inds(freq)
        
        # Use numpy's advanced indexing to quickly extract the surface levels
        # Rows with all NaNs in the pressure array will have NaN in the values
        values = spec[(np.arange(spec.shape[0]), surf_inds)]
        values[surf_inds < 0] = np.nan
        return values

    def find_surf_inds(self, pres=None) -> np.ndarray:
        """Return the index of the surface level for each sounding

        Parameters
        ----------
        pres
            Array of pressure levels (soundings-by-levels)

        Returns
        -------
        surf_inds
            Numpy array with numeric indices that give the position along the second dimension of
            ``pres`` that is the surface for each row. Values of -1 indicate that level had no
            valid pressures
        """
        if pres is None:
            with ncdf.Dataset(self.combined_file) as ds:
                pres = get_nc_var(ds, self._freq_var)
        # First check that `pres` really is pressure - should decrease monotonically (except for NaNs)
        dp = np.diff(pres, axis=1)
        assert np.all(dp[~np.isnan(dp)] < 0), 'Grid coordinate does not appear to be pressure (non monotonically decreasing)'
        
        # nanargmax gives a ValueError if it operates on an all-NaN slice, so handle such rows separately
        xx = np.all(np.isnan(pres), axis=1)
        surf_inds = np.full(pres.shape[0], -1)
        surf_inds[~xx] = np.nanargmax(pres[~xx], axis=1)
        return surf_inds


class WindowAtSurfacePlus(WindowAtSurface):
    """Computes an average of data over a number of levels at the surface.

    This uses the same code as :class:`WindowAtSurface` to find the surface
    level in each sounding, then averages ``spec_var`` over ``nlevels`` above
    the surface (including the surface). That average is the quantity returned
    in the dataframe from :meth:`compute_window_stats`.

    All inputs are the same as :class:`AbstractWindowStat` except for the additional
    required input ``nlevels``, which indicates how many levels to average. If this
    is ``3`` for instance, then the surface, surface + 1, and surface + 2 level's data
    are averaged for each sounding.
    """
    def __init__(self, combined_file: str, nlevels: int, freq_var: str = 'Pressure', spec_var: str = 'Species', window_min: float = 0, window_max: float = 1100, 
                 lon_var: str = 'Longitude', lat_var: str = 'Latitude', quality_var: str = 'Quality', filter_on_quality: bool = True, id_var: Optional[str] = None):
        super().__init__(combined_file=combined_file, freq_var=freq_var, spec_var=spec_var, window_min=window_min, window_max=window_max, 
                         lon_var=lon_var, lat_var=lat_var, quality_var=quality_var, filter_on_quality=filter_on_quality, id_var=id_var)
        if nlevels < 1:
            raise ValueError('nlevels must be >= 1')

        self._nlevels = nlevels

    @property
    def label(self):
        return f'{self._spec_var} over first {self._nlevels} levels'

    def operation(self, freq, spec):
        surf_inds = self.find_surf_inds(freq)
        values = np.full([spec.shape[0], self._nlevels], np.nan)

        for k in range(self._nlevels):
            # Use numpy's advanced indexing to quickly extract each level we want
            values[:, k] = spec[(np.arange(spec.shape[0]), surf_inds+k)]

        values = np.mean(values, axis=1)
        values[surf_inds < 0] = np.nan
        return values


class WindowPBLLapse(WindowAtSurface):
    """Compute the lapse rate between the surface and another level.

    This uses the same code as :class:`WindowAtSurface` to find the surface
    level in each sounding, then computes the difference in ``spec_var`` between
    a level above the surface (specified by ``top_level``) and the surface, 
    divided by the difference in altitude between those levels. 

    Inputs are similar to :class:`AbstractWindowStat`, with a few additional inputs:

    * ``top_level`` indicates which level's values to difference with the surface to
      compute the lapse rate. This is a 0-based index relative to the surface, so
      setting ``top_level = 2`` will difference ``surf_idx + 2`` against ``surf_idx``.
    * ``altitude_var`` is the name or path to the altitude variable in the ``combined_file``.
    * ``altitude_units`` is the units to *convert* the altitude *to*. This class will read
      the units from the altitude variable and convert the values to ``altitude_units``
      using :class:`jllutils.units.length`.
    """
    def __init__(self, combined_file: str, top_level: int, freq_var: str = 'Pressure', spec_var: str = 'Species', window_min: float = 0, window_max: float = 1100, 
                 lon_var: str = 'Longitude', lat_var: str = 'Latitude', altitude_var: str = 'Altitude', altitude_units: str = 'kilometers',
                 quality_var: str = 'Quality', filter_on_quality: bool = True, id_var: Optional[str] = None):
        super().__init__(combined_file=combined_file, freq_var=freq_var, spec_var=spec_var, window_min=window_min, window_max=window_max, 
                         lon_var=lon_var, lat_var=lat_var, quality_var=quality_var, filter_on_quality=filter_on_quality, id_var=id_var)
        if top_level < 1:
            raise ValueError('top_level must be >= 1')

        self._top_level = top_level
        self._altitude_var = altitude_var
        self._altitude_units = altitude_units

    @property
    def label(self):
        with ncdf.Dataset(self.combined_file) as ds:
            num_units = find_attribute(get_nc_var(ds, self._spec_var, read_array=False), {'units', 'units'}, return_value=True)
            denom_units = self._altitude_units
        return f'{self._spec_var} lapse rate over first {self._top_level + 1} levels ({num_units}/{denom_units})'

    def operation(self, freq, spec):
        surf_inds = self.find_surf_inds(freq)
        values = np.full([spec.shape[0], 2], np.nan)
        level_alts = np.full([spec.shape[0], 2], np.nan)

        with ncdf.Dataset(self.combined_file) as ds:
            altitude = get_nc_var(ds, self._altitude_var) 
            units = find_attribute(get_nc_var(ds, self._altitude_var, read_array=False), {'units', 'unit'}, return_value=True)
            altitude = junits.length.convert(altitude, units, self._altitude_units)

        # Use numpy's advanced indexing to quickly extract each level we want
        values[:, 0] = spec[(np.arange(spec.shape[0]), surf_inds)]
        values[:, 1] = spec[(np.arange(spec.shape[0]), surf_inds+self._top_level)]
        level_alts[:, 0] = altitude[(np.arange(spec.shape[0]), surf_inds)]
        level_alts[:, 1] = altitude[(np.arange(spec.shape[0]), surf_inds+self._top_level)]

        values = (values[:, 1] - values[:, 0]) / (level_alts[:, 1] - level_alts[:, 0])
        values[surf_inds < 0] = np.nan
        return values

class CompositeReader(AbstractWindowStat):
    """A window reader class that will combine the outputs from multiple other window readers

    Parameters
    ----------
    readers_dict
        A dictionary with other instances of :class:`AbstractWindowStat` as its values. The keys
        must be strings, they will be used as the column name for the "spec_stat" column of the
        output the corresponding reader's `compute_window_stats` method.

    readers
        An alternative to passing a dictionary, each reader may be specified with the column name 
        as its keyword.

    Notes
    -----
    The `compute_window_stats` method on this class will return a concatenated dataframe of all of
    the sub-readers' `compute_window_stats` dataframes, with the only change to the individual
    dataframes being that the `spec_stat` column is renamed to whatever the key for that reader
    was in the input dictionary/keywords.

    Each individual reader must point to the same file and return a dataframe with the same number
    of rows as the first reader, otherwise a :class:`ValueError` is raised during instantiation or
    the call to `compute_window_stats`. To concatenate properly, the individual dataframes should 
    also have the same index.
    """
    def __init__(self, readers_dict: Optional[dict] = None, **readers):
        if readers_dict is None:
            readers_dict = dict()
        readers.update(readers_dict)

        self._check_files(readers_dict)
        self.readers = readers

    @staticmethod
    def _check_files(readers):
        k1 = None
        first_file = None
        for k, r in readers.items():
            if first_file is None:
                k1 = k
                first_file = Path(r.combined_file).resolve()
            elif Path(r.combined_file).resolve() != first_file:
                raise ValueError(f'The {k} reader points to a different file than the {k1} reader')


    @property
    def label(self):
        """Return a label describing this statistic"""
        return 'Multiple statistics'

    def operation(self, freq, spec):
        """Given 2D arrays of frequency and spectral information, return a 1D vector with one value of spectral information per sounding"""
        raise NotImplementedError('`operation` should not be called directly on a CompositeReader instance')

    def compute_window_stats(self) -> pd.DataFrame:
        """Create a dataframe with the longitude, latitude, and statistics for each sounding in the combined file."""
        dfs = []
        first_name = None
        for name, reader in self.readers.items():
            this_df = reader.compute_window_stats().rename(columns={'spec_stat': name})
            if len(dfs) == 0:
                dfs.append(this_df)
                first_name = name
            elif this_df.shape[0] != dfs[0].shape[0]:
                raise ValueError(f'The {name} reader gave a dataframe with a different number of rows than the {first_name} reader')
            else:
                dfs.append(this_df[[name]])

        return pd.concat(dfs, axis=1)

        
    def _get_window(self, freq, spec):
        raise NotImplementedError('`_get_window` should not be called directly on a CompositeReader instance')
        
    
    
    
def plot_window_stat_map(window_stat: AbstractWindowStat, domain: Sequence[float] = (-128.0, -100.0, 30.0, 51.0), stat_scale=1,
                         ax=None, cblabel=None, map_features: Sequence[AbstractMapFeature] = (MapFeatureStates(),), **scatter_kws):
    """Plot a map of a spectral variable 

    Parameters
    ----------
    window_stat
        An instance of an :class:`AbstractWindowStat` child class which is used to compute the
        statistic to plot.

    domain
        The west, east, south, and north borders of the region to plot.

    stat_scale
        Multiplier to scale the statistics by before plotting.

    ax
        The axes to plot into. If not given, one is created. If given, must be have the projection
        set to :class:`cartopy.crs.PlateCarree`.

    scatter_kws
        Additional keyword arguments are passed through to :func:`matplotlib.pyplot.scatter`.
    """
    if ax is None:
        fig = plt.figure(figsize=(20, 10))
        ax = fig.add_subplot(1,1,1,projection=ccrs.PlateCarree())
        
    for feature in map_features:
        feature.add(ax)
    ax.set_extent(domain)
    ax.gridlines(draw_labels=True)
    data = window_stat.compute_window_stats()
    scatter_kws.setdefault('label', '')
    h = ax.scatter(data['longitude'], data['latitude'], c=data['spec_stat']*stat_scale, **scatter_kws)
    plt.colorbar(h, ax=ax, label=window_stat.label if cblabel is None else cblabel)


def plot_window_stat_hist(window_stat: AbstractWindowStat, stat_scale=1, ax=None, **hist_kws):
    if ax is None:
        ax = plt.gca()

    data = window_stat.compute_window_stats()
    ax.hist(data['spec_stat']*stat_scale, **hist_kws)


class AbstractBoxes(ABC):
    @property
    def nx(self) -> int:
        """Number of boxes in the longitudinal direction"""
        return self._lons.size

    @property
    def ny(self) -> int:
        """Number of boxes in the latitudinal direction"""
        return self._lats.size

    @property
    def nboxes(self) -> int:
        """Total number of boxes in the domain"""
        return self.nx * self.ny

    @property
    @abstractmethod
    def domain(self) -> Tuple[float, float, float, float]:
        """The actual domain being plotted (lonmin, lonmax, latmin, latmax). May be different from input domain depending on box alignment."""

    def iter_boxes(self, with_indices: bool = True):
        """Iterate over all the boxes defined by this instance

        Parameters
        ----------
        with_indices 
            If ``True``, the array indices for each box are returned as the first two iterator values.
            Otherwise those are omitted.

        Returns
        -------
        int
            Array index in longitudinal direction. Only given if ``with_indices`` is ``True``.

        int
            Array index in latitudinal direction. Only given if ``with_indices`` is ``True``.
            
        float
            West edge of the box.

        float
            East edge of the box.

        float
            South edge of the box.

        float
            North edge of the box.

        Notes
        -----
        Subclasses may use this implementation if they have attributes ``_lats``, ``_lons``, ``_height``,
        and ``_width``, which are the north edges, west edges, latitudinal size, and longitudinal size
        of the boxes, respectively. Otherwise a custom implementation is required.
        """
        for j, lat in enumerate(self._lats):
            for i, lon in enumerate(self._lons):
                if with_indices:
                    yield i, j, lon, lon + self._width, lat - self._height, lat
                else:
                    yield lon, lon + self._width, lat - self._height, lat

    def plot_domain(self, ax, **style):
        x1, x2, y1, y2 = self.domain
        ax.plot([x1, x1, x2, x2, x1], [y1, y2, y2, y1, y1], **style)


class RectBoxSingle(AbstractBoxes):
    def __init__(self, lonmin, lonmax, latmin, latmax):
        self._width = lonmax - lonmin
        self._height = latmax - latmin
        self.lonmin = lonmin
        self.lonmax = lonmax
        self.latmin = latmin
        self.latmax = latmax
        self._lons = np.array([lonmin])
        self._lats = np.array([latmax])

    @property
    def domain(self) -> Tuple[float, float, float, float]:
        """The actual domain being plotted (lonmin, lonmax, latmin, latmax). May be different from input domain depending on box alignment."""
        return self._lons[0], self._lons[-1]+self._width, self._lats[-1] - self._height, self._lats[0]


class RectBoxMulti(AbstractBoxes):
    """A class used to divide up soundings into multiple manually specified boxes for average spectral plots

    Paramters
    ---------
    boxes
        Sequences of lonmin, lonmax, latmin, latmax for each box.

    nx
        How many boxes to put in a row for the plots. If not given, all boxes will go in one row.
    """
    def __init__(self, *boxes, nx=None) -> None:
        self._boxes = np.array(boxes)
        self.lonmin = np.min(self._boxes[:,0])
        self.lonmax = np.max(self._boxes[:,1])
        self.latmin = np.min(self._boxes[:,2])
        self.latmax = np.max(self._boxes[:,3])
        self._width = self.lonmax - self.lonmin
        self._height = self.latmax - self.latmin

        if nx is None:
            self._nx = np.shape(self._boxes)[0]
            self._ny = 1
        else:
            n = np.shape(self._boxes)[0]
            self._nx = nx
            self._ny = (n // nx) + ((n % nx) > 0)

    @property
    def nx(self):
        return self._nx

    @property
    def ny(self):
        return self._ny

    @property
    def nboxes(self) -> int:
        return np.shape(self._boxes)[0]

    @property
    def domain(self) -> Tuple[float, float, float, float]:
        return self.lonmin, self.lonmax, self.latmin, self.latmax

    def iter_boxes(self, with_indices: bool = True):
        for irow, row in enumerate(self._boxes):
            x1, x2, y1, y2 = row
            if with_indices:
                i = irow % self.nx
                j = irow // self.nx
                yield i, j, x1, x2, y1, y2
            else:
                yield x1, x2, y1, y2




class RectBoxes(AbstractBoxes):
    """A class used to divide up soundings into boxes for average spectral plots

    This class allows you to specify the width and height (in degrees) of the boxes.

    Parameters
    ----------
    width, height
        The width (longitudinal size) and height (latitudinal size) of each box in degrees.

    lonmin, lonmax
        The west and east edges, respectively, of the domain to plot. Longitude convention must match
        that of the sounding to plot, e.g. -180 to 180 or 0 to 360.

    latmin, latmax
        The south and north edges, respectively, of the domain to plot. Longitude convention must match
        that of the sounding to plot, e.g. south is negative.
    """
    def __init__(self, width: float, height: float, lonmin: float, lonmax: float, latmin: float, latmax: float):
        self._width = width
        self._height = height
        self.lonmin = lonmin
        self.lonmax = lonmax
        self.latmin = latmin
        self.latmax = latmax
        self._lons = np.arange(self.lonmin, self.lonmax, self._width)
        self._lats = np.arange(self.latmax, self.latmin, -self._height)
    
    @property
    def domain(self) -> Tuple[float, float, float, float]:
        """The actual domain being plotted (lonmin, lonmax, latmin, latmax). May be different from input domain depending on box alignment."""
        return self._lons[0], self._lons[-1]+self._width, self._lats[-1] - self._height, self._lats[0]
        

class RectBoxesByNumber(AbstractBoxes):
    """A class used to divide up soundings into boxes for average spectral plots

    This class allows you to specify the number of boxes in the longitudinal and latitudinal directions.

    Parameters
    ----------
    lonmin, lonmax
        The west and east edges, respectively, of the domain to plot. Longitude convention must match
        that of the sounding to plot, e.g. -180 to 180 or 0 to 360.

    latmin, latmax
        The south and north edges, respectively, of the domain to plot. Longitude convention must match
        that of the sounding to plot, e.g. south is negative.

    nlon, nlat
        The number of boxes in each direction. If ``nlat`` is ``None``, it is set to be the same as ``nlon``.
    """
    def __init__(self, lonmin: float, lonmax: float, latmin: float, latmax: float, nlon: int, nlat: Optional[int] = None):
        if nlat is None:
            nlat = nlon

        width = (lonmax - lonmin)/nlon
        height = (latmax - latmin)/nlat
        self._width = width
        self._height = height
        self.lonmin = lonmin
        self.lonmax = lonmax
        self.latmin = latmin
        self.latmax = latmax
        self._lons = np.arange(self.lonmin, self.lonmax, self._width)
        self._lats = np.arange(self.latmax, self.latmin, -self._height)

        # Double check that the last edge matches our domain
        lon_edge = self._lons[-1] + self._width
        if not np.isclose(lon_edge, lonmax):
            warn(f'Longitude east edge not quite equal to specified lonmax: {lon_edge} vs. {lonmax}')
        
        lat_edge = self._lats[-1] - self._height
        if not np.isclose(lat_edge, latmin):
            warn(f'Latitude south edge not quite equal to specified latmin: {lat_edge} vs. {latmin}')

    @property
    def domain(self) -> Tuple[float, float, float, float]:
        return self.lonmin, self.lonmax, self.latmin, self.latmax

    @classmethod
    def from_profile_dict(cls, profile: dict, nlon: int, nlat: Optional[int] = None):
        """Create an instance from a profile loaded from one of the profile .yaml files

        Parameters
        ----------
        profile
            A dictionary describing the profile to use; expected to have the "full_resolution_geolocation"
            key with lat/lon bounds. 

        nlon
            Number of boxes in the longitudinal direction

        nlat
            Number of boxes in the latitudinal direction. If not given, defaults to the same as ``nlon``.
        """
        return cls(
            lonmin=profile['full_resolution_geolocation']['longitude_min'],
            lonmax=profile['full_resolution_geolocation']['longitude_max'],
            latmin=profile['full_resolution_geolocation']['latitude_min'],
            latmax=profile['full_resolution_geolocation']['latitude_max'],
            nlon=nlon, 
            nlat=nlat
        )
    
    
class AbstractSpecPlot(ABC):
    @property
    @abstractmethod
    def title(self):
        """Title to give to the overall plot."""

    @property
    @abstractmethod
    def data_file(self):
        pass

    @property
    @abstractmethod
    def n_soundings(self):
        pass

    @abstractmethod
    def plot_spectrum(self, ax, xx_box):
        """Plot the spectrum mean and quantile range
        
        Parameters
        ----------
        ax
            Axes to plot into

        xx_box
            A boolean index the same length as the number of soundings
            that is true where the soundings are in the current box to plot.
        """

    def plot_spectrum_in_box(self, ax, box: AbstractBoxes, lonvar=None, latvar=None):
        lonmin, lonmax, latmin, latmax = box.domain
        with ncdf.Dataset(self.data_file) as ds:
            if lonvar is None:
                lonvar = readers.find_var_at_path_ignore_case(ds, 'longitude')
            if latvar is None:
                latvar = readers.find_var_at_path_ignore_case(ds, 'latitude')
            lon = get_nc_var(ds, lonvar)
            lat = get_nc_var(ds, latvar)

        xx = (lon >= lonmin) & (lon <= lonmax) & (lat >= latmin) & (lat <= latmax)
        return self.plot_spectrum(ax, xx)

    def plot_spectrum_all(self, ax):
        n = self.n_soundings
        xx = np.ones(n, dtype=bool)
        self.plot_spectrum(ax, xx)




class SpecMeanAndQuantile(AbstractSpecPlot):
    """Class that plots a mean and interquantile range of a spectrum in each box.

    Parameters
    ----------
    combined_file
        Path to an output file from ``py-combine`` to plot from.

    freq_var
        Name/path of variable in ``combined_file`` to use as frequency on the x-axis.

    spec_var
        Name/path of variable in ``combined_file`` to use as the spectrum on the y-axis.

    p
        Percentiles to calculate for the background shading. Two element sequence, each value
        between 0 and 100.

    window
        Lower and upper frequency limits to plot, if not given, the full band in the ``spec_var`` is
        plotted.

    legend_kws
        Keywords passed to the ``legend`` call. Defaults are ``loc="upper right"`` and ``fontsize=9``.

    spec_style
        Keywords passed to ``plot`` for the mean spectrum. Defaults are ``color="k"`` and ``label="$N {n_spec}$"``.

    p_style
        Keywords passed to ``fill_between`` for the percentile range. Defaults are ``color="lightgray"`` and
        ``alpha=0.5``.

    filter_fxn
        If given, must be a function that accepts an array of radiance intensities and returns an array of
        the same size that is ``True`` for intensities that should be kept in the average. Different
        subclasses may convert the intensities to their preferred unit before calling this function.

    override_freq_check
        Allow plotting even if the frequencies are not the same across all soundings
    """
    def __init__(self, combined_file: str, freq_var: str, spec_var: str, p: Tuple[float, float]=[5.0, 95.0],
                window: Optional[Tuple[float, float]]=None, legend_kws: Optional[dict] = None, 
                spec_style: Optional[dict] = None, p_style: Optional[dict] = None, 
                filter_fxn: Optional[Callable[[np.ndarray], np.ndarray]] = None,
                override_freq_check: bool = False):
        self.combined_file = combined_file
        self._freq_var = freq_var
        self._spec_var = spec_var
        self._percentiles = p
        self._window = window
        self._filter_fxn = filter_fxn
        self._override_freq_check = override_freq_check
        self._leg_kws = dict() if legend_kws is None else legend_kws
        self._leg_kws.setdefault('loc', 'upper right')
        self._leg_kws.setdefault('fontsize', 9)
        
        self._spec_style = dict() if spec_style is None else spec_style
        self._spec_style.setdefault('color', 'k')
        self._spec_style.setdefault('label', '$N = {n_spec}$')
        
        self._p_style = dict() if p_style is None else p_style
        self._p_style.setdefault('color', 'lightgray')
        self._p_style.setdefault('alpha', 0.5)
        
    @property
    def title(self):
        """Title to give the overall plot"""
        if self._window is None:
            return f'{self._spec_var}'
        else:
            return f'{self._spec_var} in {self._window[0]} to {self._window[1]} cm$^{{-1}}$'

    @property
    def data_file(self):
        return self.combined_file

    @property
    def n_soundings(self):
        with ncdf.Dataset(self.combined_file) as ds:
            return ds[self._freq_var].shape[0]

    @property
    def ylabel(self):
        """Label to give the y-axis of the plot"""
        return self._spec_var
        
    def plot_spectrum(self, ax, xx_box):
        """Plot the spectrum mean and quantile range
        
        Parameters
        ----------
        ax
            Axes to plot into

        xx_box
            A boolean index the same length as the number of soundings
            that is true where the soundings are in the current box to plot.
        """
        with ncdf.Dataset(self.combined_file) as combined_ds:
            freq = get_nc_var(combined_ds, self._freq_var)
            spec = get_nc_var(combined_ds, self._spec_var)
            freq, spec = self._apply_filter(freq, spec)
        self._plot_inner(ax, xx_box, freq, spec)

    def _apply_filter(self, freq, spec):
        if self._filter_fxn is None:
            return freq, spec
        else:
            xx = self._filter_fxn(spec)
            spec[~xx] = np.nan
            return freq, spec
        
    def _plot_inner(self, ax, xx_box, freq, spec):
        if not _is_freq_consistent(freq):
            if self._override_freq_check:
                freq_delta = _freq_consistency_diff(freq)
                imax = np.argmax(np.abs(freq_delta))
                warn(f'Frequencies not consistent, but overriding the check. Max abs. difference was {freq_delta[imax]} at index {imax}')
            else:
                raise ValueError('Expected frequencies to be the same for all soundings')
            
        # Use nanmean instead of selecting the first frequency to avoid issues when the first
        # frequency is all NaNs or we overrode the consistency check
        freq = np.nanmean(freq, axis=0)
        
        if self._window is not None:
            xx_freq = (freq >= self._window[0]) & (freq <= self._window[1])
        else:
            xx_freq = np.ones(freq.shape, dtype=np.bool_)
            
        mean_spec = np.nanmean(spec[xx_box], axis=0)
        n_spec = np.shape(spec[xx_box])[0]
        spec_style = copy(self._spec_style)
        spec_style['label'] = spec_style['label'].format(n_spec=n_spec)
        ax.plot(freq[xx_freq], mean_spec[xx_freq], **spec_style)

        if self._percentiles is not None:
            percentile_spec = np.nanpercentile(spec[xx_box], self._percentiles, axis=0)
            ax.fill_between(freq[xx_freq], percentile_spec[0][xx_freq], percentile_spec[1][xx_freq], **self._p_style)
        ax.set_ylabel(self.ylabel)
        ax.legend(**self._leg_kws)


class SpecMeanAndQuantileBT(SpecMeanAndQuantile):
    """Same as :class:`SpecMeanAndQuantile` except the y-axis is converted from radiance to brightness temperature."""

    @property
    def ylabel(self):
        return f'{super().ylabel} (K)'

    def plot_spectrum(self, ax, xx_box):
        """Plot the spectrum mean and quantile range
        
        Parameters
        ----------
        ax
            Axes to plot into

        xx_box
            A boolean index the same length as the number of soundings
            that is true where the soundings are in the current box to plot.
        """
        with ncdf.Dataset(self.combined_file) as combined_ds:
            freq = get_nc_var(combined_ds, self._freq_var)
            spec = get_nc_var(combined_ds, self._spec_var)
            spec = bt(freq, spec)
            freq, spec = self._apply_filter(freq, spec)
        self._plot_inner(ax, xx_box, freq, spec)
        
        
class SpecVarDiffMeanAndQuantile(SpecMeanAndQuantile):
    """Class that plots the difference between two spectra in one file.

    All arguments are the same as :py:class:`SpecMeanAndQuantile`, with one additional
    variable, ``spec_var2``. This is a name/path of the second variable in the difference,
    i.e. the plot will be ``spec_var - spec_var2``.
    """
    def __init__(self, combined_file, freq_var, spec_var, spec_var2, p=[5.0, 95.0], window=None, legend_kws=None,  spec_style=None, p_style=None, filter_fxn=None):
        super().__init__(combined_file=combined_file, freq_var=freq_var, spec_var=spec_var, p=p, window=window, legend_kws=legend_kws,  spec_style=spec_style, p_style=p_style, filter_fxn=filter_fxn)    
        self._spec_var2 = spec_var2
        
    @property
    def title(self):
        if self._window is None:
            return f'{self._spec_var} - {self._spec_var2}'
        else:
            return f'{self._spec_var} - {self._spec_var2} in {self._window[0]} to {self._window[1]} cm$^{{-1}}$'

    @property
    def ylabel(self):
        return f'{self._spec_var} - {self._spec_var2}'
        
    def plot_spectrum(self, ax, xx_box):
        with ncdf.Dataset(self.combined_file) as combined_ds:
            freq = get_nc_var(combined_ds, self._freq_var)
            spec = get_nc_var(combined_ds, self._spec_var)
            spec2 = get_nc_var(combined_ds, self._spec_var2)
            freq, spec, spec2 = self._apply_filter(freq, spec, spec2)
        self._plot_inner(ax, xx_box, freq, spec - spec2)

    def _apply_filter(self, freq, spec, spec2):
        if self._filter_fxn is None:
            return freq, spec, spec2
        else:
            xx = self._filter_fxn(spec)
            spec[~xx] = np.nan
            xx = self._filter_fxn(spec2)
            spec2[~xx] = np.nan
            return freq, spec, spec2
        

class SpecVarDiffMeanAndQuantileBT(SpecVarDiffMeanAndQuantile):
    """Same as :class:`SpecVarDiffMeanAndQuantile` except the y-axis is converted from radiance to brightness temperature."""
    @property
    def ylabel(self):
        return f'{super().ylabel} (K)'

    def plot_spectrum(self, ax, xx_box):
        with ncdf.Dataset(self.combined_file) as combined_ds:
            freq = get_nc_var(combined_ds, self._freq_var)
            spec = get_nc_var(combined_ds, self._spec_var)
            spec = bt(freq, spec)
            spec2 = get_nc_var(combined_ds, self._spec_var2)
            spec2 = bt(freq, spec2)
            freq, spec, spec2 = self._apply_filter(freq, spec, spec2)
        self._plot_inner(ax, xx_box, freq, spec - spec2)
        
        
class SpecFileDiffMeanAndQuantile(SpecMeanAndQuantile):
    """Class to plot the difference in one spectral variable between two ``py-combine`` output files.

    The arguments are the same as :py:class:`SpecMeanAndQuantile` with two additions:

    * ``combined_file2`` is the second file, the difference will be ``combined_file - combined_file2``.
    * ``id_var`` the name/path to the sounding ID variable in the files. Used to make sure the files
      are aligned.
    """
    def __init__(self, combined_file, combined_file2, id_var, freq_var, spec_var, p=[5.0, 95.0], window=None, legend_kws=None,  spec_style=None, p_style=None):
        super().__init__(combined_file=combined_file, freq_var=freq_var, spec_var=spec_var, p=p, window=window, legend_kws=legend_kws,  spec_style=spec_style, p_style=p_style)
        self.combined_file2 = combined_file2
        self._id_var = id_var
        
    @property
    def title(self):
        if self._window is None:
            return f'{self._spec_var} difference (file1 - file2)'
        else:
            return f'{self._spec_var} difference (file1 - file2) in {self._window[0]} to {self._window[1]} cm$^{{-1}}$'
        
    def plot_spectrum(self, ax, xx_box):
        with ncdf.Dataset(self.combined_file) as ds:
            sid = get_nc_var(ds, self._id_var)
            freq = get_nc_var(ds, self._freq_var)
            spec = get_nc_var(ds, self._spec_var)
        with ncdf.Dataset(self.combined_file2) as ds:
            sid2 = get_nc_var(ds, self._id_var)
            freq2 = get_nc_var(ds, self._freq_var)
            spec2 = get_nc_var(ds, self._spec_var)
            
        _are_files_matched(sid, sid2, freq, freq2)
            
        self._plot_inner(ax, xx_box, freq, spec - spec2)
        

class SpecFileDiffMeanAndQuantileBT(SpecFileDiffMeanAndQuantile):
    """Same as :class:`SpecFileDiffMeanAndQuantile` except the y-axis is converted from radiance to brightness temperature."""
    @property
    def ylabel(self):
        return f'{super().ylabel} (K)'

    def plot_spectrum(self, ax, xx_box):
        with ncdf.Dataset(self.combined_file) as ds:
            sid = get_nc_var(ds, self._id_var)
            freq = get_nc_var(ds, self._freq_var)
            spec = get_nc_var(ds, self._spec_var)
            spec = bt(freq, spec)
        with ncdf.Dataset(self.combined_file2) as ds:
            sid2 = get_nc_var(ds, self._id_var)
            freq2 = get_nc_var(ds, self._freq_var)
            spec2 = get_nc_var(ds, self._spec_var)
            spec2 = bt(freq2, spec2)
            
        _are_files_matched(sid, sid2, freq, freq2)
            
        self._plot_inner(ax, xx_box, freq, spec - spec2)
        
class SpecMulti:
    """Plot multiple spectra/spectra differences into each axes in :py:func:`plot_box_spectra` or similar functions.

    Parameters
    ----------
    *plotters
        Instances of :py:class:`AbstractSpecPlot` or its children. Each one will be plotted in each box axes.
    """
    def __init__(self, *plotters):
        self._plotters = plotters
        
    @property
    def title(self):
        return 'Multiple'
        
    @property
    def combined_file(self):
        return self._plotters[0].combined_file
    
    def plot_spectrum(self, ax, xx_box):
        for plotter in self._plotters:
            plotter.plot_spectrum(ax, xx_box)


def plot_boxes(boxdef: RectBoxes, map_features=(_state_features,), box_cmap='Dark2', labeler: AbstractLabeler = LetterLabeler(), ax=None):
    if ax is None:
        _, ax = plt.subplots(subplot_kw={'projection': ccrs.PlateCarree()})

    for feature in map_features:
        ax.add_feature(feature, facecolor='none', edgecolor='k')
    ax.set_extent(boxdef.domain)
    if isinstance(box_cmap, str):
        box_cmap = cm.get_cmap(box_cmap)

    boxes = dict()
    for idx, (lon1, lon2, lat1, lat2) in enumerate(boxdef.iter_boxes(with_indices=False)):
        color = box_cmap(idx % box_cmap.N)
        label = labeler.get_label(idx)

        ax.plot([lon1, lon1, lon2, lon2, lon1], [lat1, lat2, lat2, lat1, lat1], 
                    color=color, ls='--')
        ax.text(0.5*(lon1+lon2), 0.5*(lat1+lat2), labeler.get_label(idx), color=color, ha='center', va='center')

        boxes[label] = {'lonmin': lon1, 'lonmax': lon2, 'latmin': lat1, 'latmax': lat2}

    return boxes
    
    
def plot_box_spectra(plotter: AbstractSpecPlot, boxdef: RectBoxes, lonvar: str = 'LONGITUDE', latvar: str = 'LATITUDE', 
                     labeler: AbstractLabeler = LetterLabeler(), sharey: bool = True, absolute_labels: bool = False, grid: bool = False,
                     x_fig_size=4, y_fig_size=2):
    """Make a plot of spectrum means or other quantities in various boxes across a domain.

    Produces a map at the top with the boxes marked out and a grid of small plots below. Each small plot shows
    the spectral quantity across all soundings in the corresponding box on the map (no quality filtering).

    Parameters
    ----------
    plotter
        An instance of :py:class:`AbstractSpecPlot` that will make the plots in each small axes.

    boxdef
        An instance of :py:class:`RectBoxes` that sets up the box grid.

    lonvar, latvar  
        The names/paths of longitude and latitude variables in the combine file pointed to by ``plotter``.

    labeler
        An :py:class:`AbstractLabeler` which is used to label the small plots and boxes.

    sharey
        Whether the small plots should all have the same y-axis limits.
    """
    # First we need to set up the plots. We'll need a few boxes at the top
    # for the map
    nx = boxdef.nx
    ny = boxdef.ny
    
    fig = plt.figure(figsize=(nx*x_fig_size, (ny+2)*y_fig_size))
    gs = GridSpec(ny+2, nx, figure=fig, wspace=0.5, hspace=0.33)
    x1 = nx // 2 - 1
    if nx % 2 == 0:
        x2 = x1 + 2
    else:
        x2 = x1 + 3
        
    ax_map = fig.add_subplot(gs[0:2, x1:x2], projection=ccrs.PlateCarree())
    ax_map.add_feature(_state_features, facecolor='none', edgecolor='k')
    ax_map.set_extent(boxdef.domain)
    if grid:
        ax_map.gridlines(draw_labels=True, ls=':')
    ax_map.set_title(plotter.title)
    
    box_cmap = cm.get_cmap('Dark2')
    
    
    with ncdf.Dataset(plotter.combined_file) as ds:
        data_lon = get_nc_var(ds, lonvar)
        data_lat = get_nc_var(ds, latvar)
        
    idx = -1
    ax_first = None
    for i, j, lon1, lon2, lat1, lat2 in boxdef.iter_boxes():

        xx = (data_lon >= lon1) & (data_lon < lon2) & (data_lat >= lat1) & (data_lat < lat2)
        if np.sum(xx) == 0:
            if absolute_labels:
                idx += 1
            continue

        idx += 1
        if ax_first is None or not sharey:
            ax = fig.add_subplot(gs[j+2,i])
            ax_first = ax
        else:
            ax = fig.add_subplot(gs[j+2,i], sharey=ax_first)
        plotter.plot_spectrum(ax, xx)
        labeler.label_axes(ax, idx)

        color = box_cmap(idx % box_cmap.N)
        ax_map.plot([lon1, lon1, lon2, lon2, lon1], [lat1, lat2, lat2, lat1, lat1], 
                    color=color, ls='--')
        ax_map.text(0.5*(lon1+lon2), 0.5*(lat1+lat2), labeler.get_label(idx), color=color, ha='center', va='center')